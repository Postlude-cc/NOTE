

# C/C++

## 内存分区



内存有五大分区:堆,栈,静态存储区(三部分:全局变量(函数外定义),常量区(字符串 数字),静态变量(static修饰))



### 堆区

new操作符本质上是使用了malloc进行内存的申请，new和malloc的区别如下：
（1）malloc是C语言中的函数，而new是C++中的操作符。
（2）malloc申请之后返回的类型是void*，而new返回的指针带有类型。
（3）malloc只负责内存的分配而不会调用类的构造函数，而new不仅会分配内存，而且会自动调用类的构造函数



### 栈

主要存放**函数的参数以及局部变量。**

以及函数ret值

在函数完成执行，系统自行释放栈区内存，不需要用户管理。



### 静态存储区

静态存储区内的变量在程序编译阶段已经分配好内存空间,静态存储区内不存在未初始化的变量。



静态存储区包括：常量区（静态常量区），全局区（全局变量区）和静态变量区（静态区）。



## new和malloc的区别

new操作符本质上是使用了malloc进行内存的申请，new和malloc的区别如下：
（1）malloc是C语言中的函数，而new是C++中的操作符。
（2）malloc申请之后返回的类型是void*，而new返回的指针带有类型。
（3）malloc只负责内存的分配而不会调用类的构造函数，而new不仅会分配内存，而且会自动调用类的构造函数



### new和new[]

new是用来产生一个堆区对象的, 而new[]是用来产生一个堆区对象数组的。

new关键字相当于先调用函数operator new为这个对象分配内存，再调用这个对象的构造函数; 

而new[]关键字相当于先调用函数operator new[]为这些对象分配内存，再依次调用这些对象的构造函数



并且如果对象自定义了析构函数,则new[]时会额外申请一片空间来存放申请对象的个数,为了方便调用析构函数



### realloc/calloc/alloca

realloc重新分配一片内存空间,缩小则剪去后半部分,若增大 要么在原来的地址增大,要么复制到新的地方增大

```C++
void *calloc ( 元素个数, 元素大小 );
```

calloc的参数包括所需元素的数量和每个元素的字节



```C++
void *alloca(size_t size);
```

功能：size是请求分配的内存大小（字节）

前面的函数在进程的堆空间中分配内存，所以需要手动free，

而alloca函数在进程的栈空间中分配内存，当调用alloca函数的函数执行结束时，alloca分配的内存也就自动释放。



## 指针和引用的区别，两者占用的空间大小



指针可以有多级，引用只能是一级 

指针初始化之后可以再改变，引用不可以再更改引用的对象

在64位系统上 int* 是8字节 int是4字节







## 智能指针

因为 C++ 使用内存的时候很容易出现野指针、悬空指针、内存泄露的问题。所以C++11引入了智能指针来管理内存。

shared_ptr允许多个指针共享同一块内存，并使用引用计数来跟踪内存的使用情况。当最后一个指向内存的shared_ptr被销毁时，内存会被自动释放。

unique_ptr则是独占所有权的智能指针，它确保只有一个指针可以拥有和管理内存。当unique_ptr被销毁时，它会自动释放内存。

使用智能指针可以简化内存管理，并减少手动释放内存的错误。它们还可以提高代码的可读性和可维护性，因为它们明确地表达了内存所有权的语义。



举例:我们使用unique_ptr来管理动态分配的整型数组。

在函数结束时，unique_ptr会自动释放内存，无需手动调用delete[]。这样可以确保内存的正确释放，避免内存泄漏。





## 内存对齐

### 为什么要内存对齐

1.  **平台原因(移植原因)**：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
2.  **性能原因**：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。



![image-20231108163256774](https://jsd.onmicrosoft.cn/gh/Postlude-cc/imagecdn@master/Typora/202311081633900.png)

尽量将字节占用大的放在结构体的最前面

对齐的原则:

假设现在结构体为:

char a;

int b;

short c;

**根据对齐原则,不足4字节的变量也会被分配到4字节的空间**

**最终内存占用应该是: 4+4+4=12字节**



如果更改顺序为:

int b;

char a;

short c;

那么最终 只需要分配 4+4=8的空间即可



### #pragma pack(n)

设定结构体、联合以及类成员变量以 n 字节方式对齐

```
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为 4 字节对齐

struct test
{
    char m1;
    double m4;
    int m3;
};

#pragma pack(pop)   // 恢复对齐状态
```



## static/extern

**static 修饰全局变量**的时候，这个全局变量**只能在本文件中访问**，

不能在其它文件中访问，即便是 extern 外部声明也不可以。

**static 修饰一个函数**，则这个函数的**只能在本文件中调用**，不能被其他文件调用。



**extern可以在头文件中进行定义 然后在需要用到这个全局变量的地方**

**对变量重新声明一次即可进行使用**



## 编译的流程

**.c/.cpp文件** 

->预处理阶段生成**.i文件**

->编译器阶段:生成**.s的汇编文件**

->汇编器阶段生成**.o的目标文件**

->链接阶段:得到**可执行程序.exe**



### 预处理阶段

处理头文件引用,宏替换,条件编译,删除注释 生成.i的预处理文件



各类预处理指令都以#开头 可以出现在文件的任何位置 作用范围直到文件末尾

所以尽可能的把预处理指令写在程序开头



**头文件**

使用< >在系统指定的磁盘路径下进行搜索 , 使用“ ”则在当前工作目录搜索,如果找不到则在系统中寻找



**宏定义**

用来替换重复出现的 **字符串**

可以是常数,表达式,字符串等等



如果想要提前终止作用域 可以用#undef

宏之间也可以嵌套引用

```c++
#define R 3.0
#define PI 3.14
#define C 2*PI*R
```

宏也可以带参数 看作函数



### 编译阶段

对代码进行词法,语法,语义分析 生成中间代码 .s文件



### 汇编阶段

将编译生成的中间代码翻译成机器指令,并生成目标文件

生成二进制的.o文件



### 链接阶段

将多个目标文件和库文件合并为一个可执行文件.exe





## sizeof和strlen区别

1 strlen()是库函数,在运行时计算	sizeof()是运算符,在编译时计算好了	

2 strlen()计算字符串的实际长度	sizeof()计算出对象使用的最大字节数，

3 strlen()的参数必须是字符型指针（传入数组时自动退化为指针）

sizeof()的参数类型多样化（数组，指针，对象，函数都可以）

 



## inline内联函数

-   相当于把内联函数里面的内容写在调用内联函数处；
-   相当于不用执行进入函数的步骤，直接执行函数体；
-   相当于宏，却比宏多了类型检查，真正具有函数特性；



优点:

1.  内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2.  相比于宏,会做安全检查或自动类型转换（同普通函数），而宏定义则不会
3.  内联函数在运行时可调试，而宏定义不可以



缺点:

代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。



**关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。**



-   inline只适合函数体内代码简单的函数数使用，大部分编译器都拒绝将大部分复杂(比如带有while、switch、递归、虚函数)的函数inlining。一个较为合理的经验准则是, 不要内联超过 10 行的函数
-   虚函数、递归函数、构造函数、析构函数都不应该被内联
    -   所有对**虚函数**的调用也都会使得inlining落空。因为`virtual`意味着”等待，直到运行期才确定调用哪个函数“，而`inline`意味着"执行前，先将调用动作替换为被调用函数的本体"。如果编译器不知道该调用哪个函数就不会inlining





## volatile关键字

```c++
volatile int i = 10; 
```



-   在 C/C++ 编程语言中，volatile 关键字可以用来提醒编译器使用 volatile 声明的变量随时有可能改变，
-   因此**编译器在代码编译时就不会对该变量进行某些激进的优化**，故而编**译生成的程序在每次存储或读取该变量时，都会直接从内存地址中读取数据**。
-   相反，如果该变量没有使用 volatile 关键字进行声明，则编译器可能会优化读取和存储操作，可能暂时使用寄存器中该变量的值，而如果这个变量由别的程序（线程）更新了的话，就会出现（内存中与寄存器中的）变量值不一致的现象。
-   const 可以是 volatile （如只读的状态寄存器）
-   指针可以是 volatile



## friend友元函数

友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员 的机制。也就是说有两种形式的友元：

（1）友元函数：普通函数对一个访问某个类中的私有或保护成员。

注意，**友元函数只是一个普通函数，并不是该类的类成员函数，它可以在任何地方调用，友元函数中通过对象名来访问该类的私有或保护成员。**



（2）友元类：类A中的成员函数访问类B中的私有或保护成员

优点：提高了程序的运行效率。

缺点：破坏了类的封装性和数据的透明性。



总结：

- 能访问私有成员

- 破坏封装性

- 友元关系不可传递

- 友元关系的单向性

- 友元声明的形式及数量不受限制



## 三大特性 —— 封装、继承、多态

### 封装

把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

关键字：public, protected, private。不写默认为 private。

-   `public` 成员：可以被任意实体访问
-   `protected` 成员：只允许被子类及本类的成员函数访问
-   `private` 成员：只允许被本类的成员函数、友元类或友元函数访问

### 继承

-   基类（父类）——> 派生类（子类）



### 多态

C++ 多态分类及实现：

1.  重载多态(编译期)：函数重载、运算符重载
2.  动态多态（运行期）：虚函数
3.  参数多态性（编译期）：类模板、函数模板



多态分为两种，一种是运行时的多态，一种是编译时的多态。前者称为动态绑定，后者称为静态绑定。动态绑定时由虚函数来实现，静态绑定是由函数重载来实现。

## virtual虚函数

虚函数的意义，每个类必须提供一个可以被调用的虚函数，但每个类可以按它们认为合适的任何方式处理。如果某个类不想做什么特别的事，可以借助于基类中提供的处理函数。

也就是说，虚函数的声明是在告诉子类的设计者，”你必须支持虚函数，但如果你不想写自己的版本，可以借助基类版本。”



-   可以将派生类的对象赋值给基类的指针或引用，反之不可
-   普通函数（非类成员函数）不能是虚函数
-   静态函数（static）不能是虚函数
-   构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）



### 抽象类

#### 纯虚函数

纯虚函数的意义是提供一个公共接口，供派生类实现。格式为在虚函数后面加上"=0"。

例如：`virtual void attack() = 0;`



纯虚函数最显著的特征是：它们必须在继承类中重新声明函数，而且它们在抽象类中往往没有定义。

定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。

纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。



声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。

**带纯虚函数的类叫虚基类/抽象类，这种基类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。**



#### 接口类

**仅含有纯虚函数的抽象类**



### 虚函数表

**同一个类的不同实例共用同一份虚函数表**, 她们都通过一个所谓的**虚函数表指针**`__vfptr`(定义为`void**`类型)指向该虚函数表.



<img src="https://blog.twofei.com/496/4-4.png" alt="4-4" style="zoom:150%;" />





## 进程/线程

**进程是表示资源分配的基本单位**，又是调度运行的基本单位。例如，用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘空间、I/O设备等。然后，把该进程放人进程的就绪队列。进程调度程序选中它，为它分配CPU以及其它有关资源，该进程才真正运行。所以，进程是系统中的并发执行的单位。

在Mac、Windows NT等采用微内核结构的操作系统中，**进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。**

### 进程之间通信方式

-   管道（PIPE）

    -   有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
        -   优点：可以实现任意关系的进程间的通信
        -   缺点：
            1.  长期存于系统中，使用不当容易出错
            2.  缓冲区有限
    -   无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
        -   优点：简单方便
        -   缺点：
            1.  局限于单向通信
            2.  只能创建在它的进程以及其有亲缘关系的进程之间
            3.  缓冲区有限

    

-   信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问

    -   优点：可以同步进程
    -   缺点：信号量有限



-   信号（Signal）：用于通知接受的进程有某种事件发生



-   消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识

    -   优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
    -   缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合

    

    

-   共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问

    -   优点：无须复制，快捷，信息量大
    -   缺点：
        1.  通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题
        2.  利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信

    

-   套接字（Socket）：可用于**不同计算机间的进程通信**

    -   优点：
        1.  传输数据为字节级，传输数据可自定义，数据量小效率高
        2.  传输数据时间短，性能高
        3.  适合于客户端和服务器端之间信息实时交互
        4.  可以加密,数据安全性强
    -   缺点：需对传输的数据进行解析，转化成应用级的数据。



### 线程之间通信方式

-   锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
    -   互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。
    -   读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。
    -   自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。
    -   条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
-   信号量机制(Semaphore)
    -   无名线程信号量
    -   命名线程信号量
-   信号机制(Signal)：类似进程间的信号处理
-   屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。



## 深拷贝和浅拷贝的区别



## C++函数调用的过程



## 单线程如何处理高并发



## 什么是野指针

野指针：指向不确定地址的指针变量。使用野指针易因内存泄露出现段错误。而造成内存泄露的原因有两个：

1.访问了没有权限的内存（平时我们正确使用指针的时候，系统应经将相应的内存分配给用户，但是如果指向没有分配的内存，系统会判定我们没有权限）

2.访问了已经释放了的内存。



### 如何规避野指针

1、指针初始化 (如果没有就初始化为NULL)

2、小心指针越界

3、指针指向空间释放即使其置为NULL

4、指针使用之前检查有效性 （例如：判断是否为NULL）







## 3.1 C++八股

1.内存

​    ①内存分区

​        几个区域分别存放什么

​        堆和栈的区别

​        static变量在哪里

​        什么const在常量区，什么const在栈区，什么const放入符号表优化

​        虚函数表既然希望类的所有对象共享为什么不放在全局区

​    ②几个基本数据类型占多少空间

​    ③内存对齐

​        为什么要内存对齐

​        自定义类型的内存对齐规则，举例子算占多少内存空间

​        什么时候不希望进行内存对齐

​        \#pragma pack

2.多态

​    ①虚函数

​        构造/析构函数能否是虚函数

​        构造/析构函数里能否调用虚函数

​        讲讲虚函数指针和虚函数表

​        虚函数指针什么时候创建、存放在哪里

​    ②模板

​        模板是要解决什么问题，有什么缺点

​        模板的声明和定义为什么不能分开写，要想分开写该怎么做

​        模板特化、偏特化

​        模板在编译时生成的代码是否会相同，生成的相同的代码如何处理

3.其他语法

​    ①继承时一般要写类的哪些成员函数

​    ②拷贝构造函数和移动构造函数，深浅拷贝等等

​    ③内联是什么，为了解决什么问题，递归函数的内联会有什么问题

​    ④野指针是什么

​    ⑤指针和引用

​        有什么区别（说越全越好）

​        值类型、引用类型，C++的值、指针、引用

​        它们两个传参时是否要复制

​        除了传值，还有什么情况C++会拷贝构造临时对象

​    ⑥new/delete和malloc/free

​        有什么区别（说越全越好）

​        delete如何知道该释放多大的空间，这些信息存在什么位置

​        delete[]和delete的区别，基本数据类型的数组使用delete可以释放完全吗

​    ⑦怎样让对象只能创建在栈/堆/内存池中

​    ⑧具体如何重载operator new

​    ⑨RTTI原理，type_info信息存在虚函数表的哪里

4.C++ 11

​    ①Lambda表达式

​        Lambda表达式如何对应到函数对象

​        圆括号传参数是如何实现的

​        方括号捕获外部变量（闭包）是如何实现的

​    ②智能指针

​        有哪些智能指针，为了解决什么问题

​        shared_ptr的引用计数机制，它的问题，如何用weak_ptr来解决

​    ③类型转换

​        四种cast简述，分别的使用场景

​        dynamic_cast和虚函数的区别（dynamic_cast是为了使用子类的非虚方法或成员变量）

​    ④右值

​        左值、右值的概念，C++哪些情况下会产生临时对象

​        移动语义

​        移动构造函数和拷贝构造函数的区别

​        转发和完美转发的概念

5.STL

​    ①vector

​        vector的capacity和扩容机制，使用时要注意什么

​        接着上一题，如果扩容时会引发自定义类型挨个复制构造，C++有什么机制来避免这一点（右值，swap）

​    ②list

​        vector和list的区别，内存、复杂度等

​    ③map

​        二叉排序树、平衡二叉树、红黑树的设计思想

​        红黑树的几个性质，各种操作的时间复杂度

​    ④unordered_map

​        哈希表跟红黑树的比较，优缺点、适用场合，各种操作的时空复杂度

​        unordered_map容器的具体实现，怎么取哈希值，怎么处理哈希冲突

6.其他问题

​    ①C++静态链接库（lib）和动态链接库（dll）的区别

​    ②顺序遍历链表和顺序遍历数组哪个更快，为什么（我答的数组，原因先猜的不用指针寻址，再猜的cache命中率高，面试官都不认可）

​    ③memory_move和memory_copy两者的作用和区别

​    ④一段代码怎么样在main函数之前调用

​    ⑤你觉得C++有什么功能跟面向对象的三大特性相悖


链接：https://www.nowcoder.com/discuss/428252230693683200?sourceSSR=search
来源：牛客网





# 数据结构

## 平衡二叉树和红黑树、B+树的区别